# 🔐 파일과 레코드 잠금 (File & Record Locking)

## 📌 프로세스 간 데이터 교환
프로세스 간 데이터를 공유하는 대표적인 방법은 **파일을 매개로 한 간접 통신**입니다.

### ✔️ 동작 원리
- **한 프로세스가 파일에 데이터를 쓰고**,  
- **다른 프로세스가 해당 데이터를 읽는 방식**

### ⚠️ 발생 가능한 문제
- 한 프로세스가 **수정 중인 파일을 다른 프로세스가 읽을 경우** → 데이터 불일치
- 두 프로세스가 **동시에 같은 파일에 쓰는 경우** → 경합(Race Condition)

---

## 🔒 파일 잠금 (Locking)

### ✅ 목적
- **동시 접근 제어**: 여러 프로세스가 파일에 동시에 접근하는 것을 방지
- **데이터 무결성 보장**

### 📂 잠금의 종류

| 종류 | 접근 허용 | 설명 |
|------|------------|------|
| 🔓 읽기 잠금 (Read Lock) | 여러 프로세스 가능 | 데이터는 읽기 전용이며, **수정은 불가** |
| ✍️ 쓰기 잠금 (Write Lock) | 단일 프로세스만 가능 | 데이터 **수정 전용**, **독점적 접근** 필요 |

---

## 🔐 권고 잠금 vs 강제 잠금

| 구분 | 권고 잠금 (Advisory) | 강제 잠금 (Mandatory) |
|------|---------------------|------------------------|
| 적용 여부 | 선택적 (규칙 자율) | **커널 강제 적용** |
| 무시 가능 여부 | ✔️ 가능 | ❌ 불가능 |
| 성능 | 효율적 | 시스템 부하 증가 |
| 사용 조건 | 모두가 잠금 규칙을 **자발적으로 준수** | `-o mand` 옵션으로 마운트 필요 (Linux) |

---

## 🛠️ 파일 잠금 구현 방법

### 1. `fcntl()` 함수

```c
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>

int fcntl(int fd, int cmd, struct flock *lock);
```

| 매개변수 | 설명 |
|----------|------|
| `fd` | 파일 디스크립터 |
| `cmd` | `F_GETLK`, `F_SETLK`, `F_SETLKW` |
| `flock` | 잠금 정보 구조체 |

> ✅ `F_SETLKW`는 **블로킹 방식**으로 잠금이 풀릴 때까지 대기합니다.

---

### 2. `lockf()` 함수

```c
#include <unistd.h>

int lockf(int fd, int cmd, off_t len);
```

| `cmd` | 기능 |
|-------|------|
| `F_LOCK` | **대기하며** 잠금 설정 |
| `F_TLOCK` | 잠금 불가 시 **즉시 실패** |
| `F_ULOCK` | 잠금 해제 |
| `F_TEST` | 잠금 여부 검사 |

---

# 📁 C 언어의 파일 입출력

### 🔄 파일 처리 단계
1. **파일 열기**: `fopen()`
2. **입출력 수행**: `fgetc()`, `fprintf()` 등
3. **파일 닫기**: `fclose()`

### 📌 파일 열기 예시

```c
FILE *fp = fopen("data.txt", "r");
```

| 모드 | 설명 |
|------|------|
| `"r"` | 읽기 전용 |
| `"w"` | 쓰기 전용 (기존 내용 삭제) |
| `"a"` | 추가 모드 |

---

### 📤 파일 입출력 함수 요약

| 구분 | 표준 I/O 함수 | 파일 전용 함수 |
|------|----------------|-----------------|
| 입력 (문자) | `getchar()` | `fgetc()`, `getc()` |
| 출력 (문자) | `putchar()` | `fputc()`, `putc()` |
| 입력 (문자열) | `gets()` | `fgets()` |
| 출력 (문자열) | `puts()` | `fputs()` |
| 입력 (형식) | `scanf()` | `fscanf()` |
| 출력 (형식) | `printf()` | `fprintf()` |

---

## 🚨 scanf() 개행 문제 해결법

### 문제
```c
scanf("%d", &x); 
scanf("%c", &ch); // 개행 문자가 그대로 ch에 저장됨
```

### 해결 방법
1. **`getchar()`로 개행 문자 소비**
2. **`scanf(" %c", &ch)` → 공백 추가**
3. **`fflush(stdin);` (비표준)**

---

# 🚀 고급 I/O 처리

### 📦 버퍼링 방식

| 방식 | 설명 | 사용 예 |
|------|------|--------|
| Fully Buffered | 버퍼가 꽉 차면 I/O | 디스크 파일 |
| Line Buffered | 줄 단위 I/O | 터미널 입력 |
| Unbuffered | 버퍼 없음 | `stderr` (에러 출력) |

---

# ⚙️ 프로세스와 제어 명령

| 명령어 | 설명 |
|--------|------|
| `ps` | 현재 프로세스 상태 확인 |
| `kill PID` | 프로세스 강제 종료 |
| `wait [PID]` | 자식 프로세스 종료 대기 |
| `sleep n` | n초 대기 |
| `exit [code]` | 종료 코드와 함께 프로세스 종료 |

### 🔁 전면 / 후면 처리 예시

```bash
(sleep 10; echo 끝남) &
echo 다음 명령 실행됨
```

---

## 🔚 C 프로그램의 시작과 종료

- `main()`은 C 시작 루틴에 의해 호출됨
- `exit()` 호출 시:
  - 모든 파일 스트림을 닫고
  - 출력 버퍼를 디스크에 저장하고
  - 종료 코드를 부모에게 전달

```c
exit(0);     // 정상 종료
_exit(1);    // 뒷정리 없이 즉시 종료
```

---

> 🔍 **참고**  
> 이 문서는 시스템 프로그래밍 수업, Linux 커널 I/O 개념 학습, 그리고 파일 기반 IPC(Inter-Process Communication) 이해를 위한 개요 자료입니다.
